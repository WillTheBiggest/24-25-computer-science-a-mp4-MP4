Your goal is to create an array utility class called IntArrayMethods.java. You
will be required to write several methods which are listed below. An autograder
is provided for you to test your code.

public class IntArrayMethods {

 public static int arraySum(int[] a) {
 int sum = 0;
  for (int num : a) {
  sum += num;
 }
 return sum;
 }

 public static double arrayMean(int[] a) {
  if (a.length == 0) return 0.0;
 return (double) arraySum(a) / a.length;
 }

public static int arrayMin(int[] a) {
  if (a.length == 0) throw new IllegalArgumentException("Array cannot be empty.");
 int min = a[0];
  for (int num : a) {
  if (num < min) {
  min = num;
 }
  }
 return min;
  }
 public static int arrayMax(int[] a) {
 if (a.length == 0) throw new IllegalArgumentException("Array cannot be empty.");
 int max = a[0];
 for (int num : a) {
  if (num > max) {
  max = num;
  }
  }
 return max;
 }

 public static boolean[] arrayLocalMin(int[] a) {
 boolean[] result = new boolean[a.length];
  if (a.length < 3) return result;
  for (int i = 1; i < a.length - 1; i++) {
 if (a[i] < a[i - 1] && a[i] < a[i + 1]) {
  result[i] = true;
 }
 }
  return result;
 }

 public static boolean[] arrayLocalMax(int[] a) {
 boolean[] result = new boolean[a.length];
 if (a.length < 3) return result;
 for (int i = 1; i < a.length - 1; i++) {
 if (a[i] > a[i - 1] && a[i] > a[i + 1]) {
 result[i] = true;
 }
 }
 return result;
  }
 public static int arrayMode(int[] a) {
 if (a.length == 0) throw new IllegalArgumentException("Array cannot be empty.");
 java.util.Map<Integer, Integer> frequencyMap = new java.util.HashMap<>();
  for (int num : a) {
 frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
 }
 int mode = a[0];
 int maxCount = 0;
 for (java.util.Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
 if (entry.getValue() > maxCount) {
 mode = entry.getKey();
 maxCount = entry.getValue();
 }
 }
  return mode;
    

public static int arrayCount(int[] a, int b){
}
  arrayCount determines the number of occurences of the parameter b in the array
  and returns that value.

public static boolean arrayContainsDuplicates(int[] a)
  arrayCountainsDuplicates determines if any duplicate values exist within the
  array and returns true if this occurs and false otherwise.

public static boolean arrayAllEqual(int[] a)
  arrayAllEqual determines if all of the items in the array are the same and
  returns true if this is the case and false otherwise.

public static double[] arrayRollingAverage(int[] a, b)
  arrayRollingAverage calculates a rolling average of b values for each index in
  the array. These values are stored and then returned in an array of doubles.
  For example, the returned value at index i should contain the average of the
  value at index i and the additional b-1 values before it. If less than b-1
  values occur before index i, then an average will be calculated using just the
  existing values.

public static int[] arrayShift(int[] a, int b)
  arrayShift returns an array of values shifted by b places from the original
  array. For example, an item at index i will be shifted to index i+b. If i+b is
  out of bounds of the array, then values should wrap back around to the start
  of the array.

public static int[] arrayReverse(int[] a)
  arrayReverse returns the original array in reverse order.
